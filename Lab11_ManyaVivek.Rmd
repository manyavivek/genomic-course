---
title: "Lab11"
author: "Manya Vivek"
date: "11/9/2020"
output: html_document
---


```{r}
library(dada2); packageVersion("dada2")
```

#### CHANGE ME to the directory containing the fastq files after unzipping.
```{r}
path <- "data/MiSeq_SOP"  
list.files(path)
```
##### Forward and reverse fastq filenames have format: SAMPLENAME_R1_001.fastq and SAMPLENAME_R2_001.fastq
```{r}
fnFs <- sort(list.files(path, pattern="_R1_001.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2_001.fastq", full.names = TRUE))
```

##### Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
```{r}
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
```

# Inspect read quality profiles

##### Visualizing the quality profiles of the foward reads

```{r}
plotQualityProfile(fnFs[1:2])
```

##### Visualize the quality control of the reverse reads 

The reverse reads are of significantly worse quality. Trimming as the average quality crash will improve the alogorithm's sensitivity to rare sequence variants. 
```{r}
plotQualityProfile(fnRs[1:2])
```

# Filter and Trim 

place filtered files in filtered/ subdirectory 
```{r}
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```


```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE) # The maxEE parameter sets the maximum number of “expected errors” allowed in a read, which is a better filter than simply averaging quality scores.
head(out)
```
# Learn the Error Rates

* Parametric error model (err) and every amplicon dataset has a different set of error rates.

* "LearnErrors" <- method learns this error model from the data, by alternating estimation of the error rates and inference of sample composition until they converge on a jointly consistent solution. 

```{r}
errF <- learnErrors(filtFs, multithread = TRUE)
```
```{r}
errR <- learnErrors(filtRs, multithread = TRUE)
```
```{r}
plotErrors(errF, nominalQ=TRUE)
```

```{r}
plotErrors(errR, nominalQ=TRUE)
```

# Sample Inference 

```{r}
dadaFs <- dada(filtFs, err = errF, multithread = TRUE)
```
```{r}
dadaRs <- dada(filtRs, err = errR, multithread = TRUE)
```
##### Inspecting the returned dada-class object:

```{r}
dadaFs[[1]]
```

# Merge Paired reading 

Merge fowards and reverse reads together to obtain the full denoised sequences. 

```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
# Inspect the merger data.frame from the first sample
head(mergers[[1]])
```

